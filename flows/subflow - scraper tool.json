{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-GwNsP",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "url",
            "id": "RobustWebScraperComponent-M1M0q",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ChatInput-GwNsP{œdataTypeœ:œChatInputœ,œidœ:œChatInput-GwNsPœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-RobustWebScraperComponent-M1M0q{œfieldNameœ:œurlœ,œidœ:œRobustWebScraperComponent-M1M0qœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-GwNsP",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-GwNsPœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "RobustWebScraperComponent-M1M0q",
        "targetHandle": "{œfieldNameœ:œurlœ,œidœ:œRobustWebScraperComponent-M1M0qœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "RobustWebScraperComponent",
            "id": "RobustWebScraperComponent-M1M0q",
            "name": "data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "data",
            "id": "ParseData-8WTbu",
            "inputTypes": [
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-RobustWebScraperComponent-M1M0q{œdataTypeœ:œRobustWebScraperComponentœ,œidœ:œRobustWebScraperComponent-M1M0qœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}-ParseData-8WTbu{œfieldNameœ:œdataœ,œidœ:œParseData-8WTbuœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "RobustWebScraperComponent-M1M0q",
        "sourceHandle": "{œdataTypeœ:œRobustWebScraperComponentœ,œidœ:œRobustWebScraperComponent-M1M0qœ,œnameœ:œdataœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParseData-8WTbu",
        "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œParseData-8WTbuœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParseData",
            "id": "ParseData-8WTbu",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-7Eeu3",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ParseData-8WTbu{œdataTypeœ:œParseDataœ,œidœ:œParseData-8WTbuœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-7Eeu3{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-7Eeu3œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ParseData-8WTbu",
        "sourceHandle": "{œdataTypeœ:œParseDataœ,œidœ:œParseData-8WTbuœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-7Eeu3",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-7Eeu3œ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "RobustWebScraperComponent-M1M0q",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": true,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Advanced web scraper using ZenDriver with comprehensive data extraction capabilities",
            "display_name": "Robust Web Scraper",
            "documentation": "https://github.com/username/repo",
            "edited": true,
            "field_order": [
              "url",
              "headless",
              "timeout",
              "wait_time",
              "extract_tables",
              "extract_financial_tables",
              "extract_forms",
              "extract_links",
              "extract_images",
              "extract_text",
              "extract_metadata",
              "max_tables",
              "max_links",
              "max_images"
            ],
            "frozen": false,
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Scraped Data",
                "group_outputs": false,
                "hidden": null,
                "method": "scrape_website",
                "name": "data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"\nLangflow Custom Component for Robust ZenDriver Web Scraper\n\"\"\"\n\nimport asyncio\nimport json\nimport datetime\nfrom typing import Dict, List, Any, Optional, Union\nfrom urllib.parse import urljoin, urlparse\n\n# Langflow imports\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs import StrInput, BoolInput, IntInput\nfrom langflow.template import Output\nfrom langflow.schema import Data\nimport zendriver as zd\n\n\nclass RobustWebScraperComponent(Component):\n    display_name: str = \"Robust Web Scraper\"\n    description: str = \"Advanced web scraper using ZenDriver with comprehensive data extraction capabilities\"\n    documentation: str = \"https://github.com/username/repo\"  # Update with actual documentation URL\n    beta: bool = True\n    \n    inputs = [\n        MessageTextInput(name=\"url\", display_name=\"URL\", info=\"The URL to scrape\", required=True),\n        BoolInput(name=\"headless\", display_name=\"Headless Mode\", info=\"Run browser in headless mode (recommended for production)\", value=True),\n        IntInput(name=\"timeout\", display_name=\"Timeout\", info=\"Page load timeout in seconds\", value=30),\n        IntInput(name=\"wait_time\", display_name=\"Wait Time\", info=\"Wait time for dynamic content to load (seconds)\", value=8),\n        BoolInput(name=\"extract_tables\", display_name=\"Extract Tables\", info=\"Extract all tables from the webpage\", value=True),\n        BoolInput(name=\"extract_financial_tables\", display_name=\"Extract Financial Data\", info=\"Extract and parse financial/crypto data tables\", value=True),\n        BoolInput(name=\"extract_forms\", display_name=\"Extract Forms\", info=\"Extract form information\", value=True),\n        BoolInput(name=\"extract_links\", display_name=\"Extract Links\", info=\"Extract all links from the webpage\", value=True),\n        BoolInput(name=\"extract_images\", display_name=\"Extract Images\", info=\"Extract image information\", value=True),\n        BoolInput(name=\"extract_text\", display_name=\"Extract Text\", info=\"Extract text content from the webpage\", value=True),\n        BoolInput(name=\"extract_metadata\", display_name=\"Extract Metadata\", info=\"Extract page metadata and meta tags\", value=True),\n        IntInput(name=\"max_tables\", display_name=\"Max Tables\", info=\"Maximum number of tables to extract\", value=20),\n        IntInput(name=\"max_links\", display_name=\"Max Links\", info=\"Maximum number of links to extract\", value=200),\n        IntInput(name=\"max_images\", display_name=\"Max Images\", info=\"Maximum number of images to extract\", value=50),\n    ]\n    \n    outputs = [\n        Output(display_name=\"Scraped Data\", name=\"data\", method=\"scrape_website\")\n    ]\n\n\n\n    def scrape_website(self) -> Data:\n        \"\"\"\n        Main method that executes the web scraping\n        \"\"\"\n        \n        # Build configuration from inputs\n        config = {\n            'extract_tables': self.extract_tables,\n            'extract_financial_tables': self.extract_financial_tables,\n            'extract_forms': self.extract_forms,\n            'extract_links': self.extract_links,\n            'extract_images': self.extract_images,\n            'extract_text': self.extract_text,\n            'extract_metadata': self.extract_metadata,\n            'wait_time': self.wait_time,\n            'max_tables': self.max_tables,\n            'max_links': self.max_links,\n            'max_images': self.max_images,\n        }\n\n        # Run the async scraper\n        result = self._run_scraper(self.url, config, self.headless, self.timeout)\n        \n        # Convert result to Langflow Data format\n        return Data(value=result)\n\n    def _run_scraper(self, url: str, config: Dict, headless: bool, timeout: int) -> Dict:\n        \"\"\"\n        Run the async scraper in a synchronous context\n        \"\"\"\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            return loop.run_until_complete(self._scrape_async(url, config, headless, timeout))\n        finally:\n            loop.close()\n\n    async def _scrape_async(self, url: str, config: Dict, headless: bool, timeout: int) -> Dict:\n        \"\"\"\n        Async scraper method adapted from RobustZenDriverScraper\n        \"\"\"\n        scraper = RobustZenDriverScraper(headless=headless, timeout=timeout)\n        async with scraper:\n            return await scraper.scrape_website(url, config)\n\n\nclass RobustZenDriverScraper:\n    \"\"\"\n    Embedded scraper class (adapted from the original)\n    \"\"\"\n    def __init__(self, headless: bool = True, timeout: int = 30):\n        self.headless = headless\n        self.timeout = timeout\n        self.browser = None\n    \n    async def __aenter__(self):\n        self.browser = await zd.start(headless=self.headless)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if self.browser:\n            await self.browser.stop()\n    \n    async def scrape_website(self, url: str, config: Optional[Dict] = None) -> Dict[str, Any]:\n        \"\"\"\n        Robust website scraping with comprehensive error handling\n        \"\"\"\n        if not self.browser:\n            raise RuntimeError(\"Browser not initialized. Use async context manager.\")\n        \n        # Default configuration\n        default_config = {\n            'extract_tables': True,\n            'extract_financial_tables': True,\n            'extract_forms': True,\n            'extract_links': True,\n            'extract_images': True,\n            'extract_text': True,\n            'extract_metadata': True,\n            'extract_structured_data': True,\n            'wait_time': 8,\n            'max_tables': 20,\n            'max_links': 200,\n            'max_images': 50,\n            'detect_data_types': True,\n            'extract_page_stats': True\n        }\n        \n        config = {**default_config, **(config or {})}\n        \n        try:\n            # Navigate to page\n            page = await self.browser.get(url)\n            \n            # Smart waiting for content to load\n            await self._wait_for_content(page, config['wait_time'])\n            \n            # Initialize result structure\n            result = {\n                'url': url,\n                'final_url': None,\n                'status': 'success',\n                'timestamp': datetime.datetime.now().isoformat(),\n                'page_info': {},\n                'content': {},\n                'data': {\n                    'tables': [],\n                    'financial_data': [],\n                    'forms': [],\n                    'links': [],\n                    'images': []\n                },\n                'metadata': {},\n                'statistics': {},\n                'errors': []\n            }\n            \n            # Get final URL\n            try:\n                result['final_url'] = await page.evaluate('window.location.href')\n            except Exception as e:\n                result['errors'].append(f\"Could not get final URL: {str(e)}\")\n                result['final_url'] = url\n            \n            # Extract page info\n            if config['extract_metadata']:\n                try:\n                    result['page_info'] = await self._extract_page_info(page)\n                    result['metadata'] = await self._extract_metadata(page)\n                except Exception as e:\n                    result['errors'].append(f\"Error extracting page info: {str(e)}\")\n            \n            # Extract tables\n            if config['extract_tables']:\n                try:\n                    result['data']['tables'] = await self._extract_tables(page, config['max_tables'])\n                except Exception as e:\n                    result['errors'].append(f\"Error extracting tables: {str(e)}\")\n            \n            # Extract financial/crypto data specifically\n            if config['extract_financial_tables']:\n                try:\n                    result['data']['financial_data'] = await self._extract_financial_data(page)\n                except Exception as e:\n                    result['errors'].append(f\"Error extracting financial data: {str(e)}\")\n            \n            # Extract forms\n            if config['extract_forms']:\n                try:\n                    result['data']['forms'] = await self._extract_forms(page)\n                except Exception as e:\n                    result['errors'].append(f\"Error extracting forms: {str(e)}\")\n            \n            # Extract links\n            if config['extract_links']:\n                try:\n                    result['data']['links'] = await self._extract_links(page, config['max_links'])\n                except Exception as e:\n                    result['errors'].append(f\"Error extracting links: {str(e)}\")\n            \n            # Extract images\n            if config['extract_images']:\n                try:\n                    result['data']['images'] = await self._extract_images(page, config['max_images'])\n                except Exception as e:\n                    result['errors'].append(f\"Error extracting images: {str(e)}\")\n            \n            # Extract text content\n            if config['extract_text']:\n                try:\n                    result['content'] = await self._extract_text_content(page)\n                except Exception as e:\n                    result['errors'].append(f\"Error extracting text: {str(e)}\")\n            \n            # Generate statistics\n            if config.get('extract_page_stats', True):\n                try:\n                    result['statistics'] = self._generate_statistics(result)\n                except Exception as e:\n                    result['errors'].append(f\"Error generating statistics: {str(e)}\")\n            \n            return result\n            \n        except Exception as e:\n            return {\n                'url': url,\n                'status': 'error',\n                'error': str(e),\n                'error_type': type(e).__name__,\n                'timestamp': datetime.datetime.now().isoformat()\n            }\n    \n    async def _wait_for_content(self, page, wait_time: int):\n        \"\"\"Wait for dynamic content to load\"\"\"\n        # Initial wait\n        await asyncio.sleep(2)\n        \n        # Wait for loading indicators to disappear\n        loading_selectors = [\n            '.loading', '.loader', '.spinner', '.loading-spinner',\n            '.skeleton', '.placeholder', '[data-loading=\"true\"]'\n        ]\n        \n        for selector in loading_selectors:\n            try:\n                await page.wait_for(selector, state='hidden', timeout=3000)\n            except:\n                continue\n        \n        # Additional wait for dynamic content\n        await asyncio.sleep(wait_time)\n    \n    async def _extract_page_info(self, page) -> Dict:\n        \"\"\"Extract basic page information\"\"\"\n        info_script = \"\"\"\n        (function() {\n            return {\n                title: document.title || null,\n                url: window.location.href,\n                domain: window.location.hostname,\n                path: window.location.pathname,\n                ready_state: document.readyState,\n                referrer: document.referrer || null,\n                last_modified: document.lastModified || null\n            };\n        })()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(info_script)\n        except Exception as e:\n            return {'error': str(e)}\n    \n    async def _extract_metadata(self, page) -> Dict:\n        \"\"\"Extract page metadata\"\"\"\n        meta_script = \"\"\"\n        (function() {\n            const meta = {\n                description: null,\n                keywords: null,\n                author: null,\n                viewport: null,\n                charset: document.charset || null,\n                lang: document.documentElement.lang || null,\n                og: {},\n                twitter: {}\n            };\n            \n            const metaTags = document.querySelectorAll('meta');\n            for (let i = 0; i < metaTags.length; i++) {\n                const tag = metaTags[i];\n                const name = tag.getAttribute('name') || tag.getAttribute('property') || tag.getAttribute('http-equiv');\n                const content = tag.getAttribute('content');\n                \n                if (name && content) {\n                    if (name === 'description') meta.description = content;\n                    else if (name === 'keywords') meta.keywords = content;\n                    else if (name === 'author') meta.author = content;\n                    else if (name === 'viewport') meta.viewport = content;\n                    else if (name.indexOf('og:') === 0) {\n                        meta.og[name.replace('og:', '')] = content;\n                    }\n                    else if (name.indexOf('twitter:') === 0) {\n                        meta.twitter[name.replace('twitter:', '')] = content;\n                    }\n                }\n            }\n            \n            return meta;\n        })()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(meta_script)\n        except Exception as e:\n            return {'error': str(e)}\n    \n    async def _extract_tables(self, page, max_tables: int) -> List[Dict]:\n        \"\"\"Extract table data with robust error handling\"\"\"\n        tables_script = f\"\"\"\n        (function() {{\n            const tables = [];\n            const tableTags = document.querySelectorAll('table');\n            const maxTables = Math.min(tableTags.length, {max_tables});\n            \n            for (let i = 0; i < maxTables; i++) {{\n                try {{\n                    const table = tableTags[i];\n                    const tableData = {{\n                        index: i,\n                        id: table.id || null,\n                        className: table.className || null,\n                        headers: [],\n                        rows: [],\n                        row_count: 0,\n                        col_count: 0\n                    }};\n                    \n                    // Extract headers\n                    const headerCells = table.querySelectorAll('thead tr:first-child th, thead tr:first-child td, tr:first-child th');\n                    for (let j = 0; j < headerCells.length; j++) {{\n                        const cell = headerCells[j];\n                        tableData.headers.push({{\n                            text: cell.textContent.trim(),\n                            index: j\n                        }});\n                    }}\n                    \n                    // Extract data rows\n                    const rows = table.querySelectorAll('tbody tr, tr');\n                    for (let j = 0; j < Math.min(rows.length, 100); j++) {{\n                        const row = rows[j];\n                        const cells = row.querySelectorAll('td, th');\n                        \n                        if (cells.length === 0) continue;\n                        \n                        const rowData = [];\n                        for (let k = 0; k < cells.length; k++) {{\n                            const cell = cells[k];\n                            rowData.push({{\n                                text: cell.textContent.trim(),\n                                html: cell.innerHTML,\n                                tag: cell.tagName.toLowerCase()\n                            }});\n                        }}\n                        \n                        if (rowData.length > 0) {{\n                            tableData.rows.push(rowData);\n                        }}\n                    }}\n                    \n                    tableData.row_count = tableData.rows.length;\n                    tableData.col_count = tableData.headers.length || (tableData.rows[0] ? tableData.rows[0].length : 0);\n                    \n                    tables.push(tableData);\n                }} catch (e) {{\n                    // Skip problematic table\n                }}\n            }}\n            \n            return tables;\n        }})()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(tables_script)\n        except Exception as e:\n            return []\n    \n    async def _extract_financial_data(self, page) -> List[Dict]:\n        \"\"\"Extract financial/crypto data with specific parsing\"\"\"\n        financial_script = \"\"\"\n        (function() {\n            const financialData = [];\n            \n            // Look for tables that contain financial data\n            const tables = document.querySelectorAll('table');\n            \n            for (let i = 0; i < tables.length; i++) {\n                const table = tables[i];\n                const rows = table.querySelectorAll('tr');\n                \n                if (rows.length < 2) continue;\n                \n                // Check if this looks like a financial table\n                const headerRow = table.querySelector('thead tr, tr:first-child');\n                let isFinancialTable = false;\n                \n                if (headerRow) {\n                    const headerText = headerRow.textContent.toLowerCase();\n                    const financialKeywords = [\n                        'price', 'market cap', 'volume', 'change', 'currency',\n                        'crypto', 'coin', 'btc', 'eth', 'usd', '%', '$'\n                    ];\n                    \n                    isFinancialTable = financialKeywords.some(keyword => \n                        headerText.indexOf(keyword) !== -1\n                    );\n                }\n                \n                if (!isFinancialTable) continue;\n                \n                const tableData = {\n                    table_index: i,\n                    table_id: table.id || null,\n                    data: []\n                };\n                \n                // Extract headers\n                let headers = [];\n                if (headerRow) {\n                    const headerCells = headerRow.querySelectorAll('th, td');\n                    for (let j = 0; j < headerCells.length; j++) {\n                        headers.push(headerCells[j].textContent.trim());\n                    }\n                }\n                \n                // Extract data rows\n                for (let j = 1; j < Math.min(rows.length, 50); j++) {\n                    const row = rows[j];\n                    const cells = row.querySelectorAll('td, th');\n                    \n                    if (cells.length === 0) continue;\n                    \n                    const rowData = {};\n                    for (let k = 0; k < cells.length; k++) {\n                        const cell = cells[k];\n                        const headerName = headers[k] || 'column_' + k;\n                        const cellText = cell.textContent.trim();\n                        \n                        // Parse financial values\n                        let parsedValue = cellText;\n                        if (cellText.match(/^\\\\$[\\\\d,]+\\\\.?\\\\d*$/)) {\n                            // Price format: $123.45\n                            parsedValue = {\n                                raw: cellText,\n                                numeric: parseFloat(cellText.replace(/[$,]/g, ''))\n                            };\n                        } else if (cellText.match(/^[+-]?[\\\\d.]+%$/)) {\n                            // Percentage format: +2.5%\n                            parsedValue = {\n                                raw: cellText,\n                                numeric: parseFloat(cellText.replace('%', ''))\n                            };\n                        } else if (cellText.match(/^[\\\\d,]+\\\\.?\\\\d*[KMBT]?$/)) {\n                            // Volume format: 1.5B, 250M\n                            let multiplier = 1;\n                            let numStr = cellText;\n                            if (cellText.endsWith('K')) {\n                                multiplier = 1000;\n                                numStr = cellText.slice(0, -1);\n                            } else if (cellText.endsWith('M')) {\n                                multiplier = 1000000;\n                                numStr = cellText.slice(0, -1);\n                            } else if (cellText.endsWith('B')) {\n                                multiplier = 1000000000;\n                                numStr = cellText.slice(0, -1);\n                            } else if (cellText.endsWith('T')) {\n                                multiplier = 1000000000000;\n                                numStr = cellText.slice(0, -1);\n                            }\n                            \n                            parsedValue = {\n                                raw: cellText,\n                                numeric: parseFloat(numStr.replace(/,/g, '')) * multiplier\n                            };\n                        }\n                        \n                        rowData[headerName] = parsedValue;\n                    }\n                    \n                    if (Object.keys(rowData).length > 0) {\n                        tableData.data.push(rowData);\n                    }\n                }\n                \n                if (tableData.data.length > 0) {\n                    financialData.push(tableData);\n                }\n            }\n            \n            return financialData;\n        })()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(financial_script)\n        except Exception as e:\n            return []\n    \n    async def _extract_forms(self, page) -> List[Dict]:\n        \"\"\"Extract form information\"\"\"\n        forms_script = \"\"\"\n        (function() {\n            const forms = [];\n            const formTags = document.querySelectorAll('form');\n            \n            for (let i = 0; i < formTags.length; i++) {\n                const form = formTags[i];\n                const formData = {\n                    index: i,\n                    id: form.id || null,\n                    action: form.action || null,\n                    method: form.method || 'get',\n                    fields: []\n                };\n                \n                const fields = form.querySelectorAll('input, select, textarea');\n                for (let j = 0; j < fields.length; j++) {\n                    const field = fields[j];\n                    formData.fields.push({\n                        tag: field.tagName.toLowerCase(),\n                        type: field.type || null,\n                        name: field.name || null,\n                        placeholder: field.placeholder || null,\n                        required: field.required || false\n                    });\n                }\n                \n                forms.push(formData);\n            }\n            \n            return forms;\n        })()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(forms_script)\n        except Exception as e:\n            return []\n    \n    async def _extract_links(self, page, max_links: int) -> List[Dict]:\n        \"\"\"Extract links\"\"\"\n        links_script = f\"\"\"\n        (function() {{\n            const links = [];\n            const linkTags = document.querySelectorAll('a[href]');\n            const maxLinks = Math.min(linkTags.length, {max_links});\n            \n            for (let i = 0; i < maxLinks; i++) {{\n                const link = linkTags[i];\n                const href = link.getAttribute('href');\n                \n                if (href) {{\n                    try {{\n                        const absoluteUrl = new URL(href, window.location.href).href;\n                        links.push({{\n                            text: link.textContent.trim(),\n                            href: href,\n                            absolute_url: absoluteUrl,\n                            target: link.getAttribute('target') || null\n                        }});\n                    }} catch (e) {{\n                        // Skip invalid URLs\n                    }}\n                }}\n            }}\n            \n            return links;\n        }})()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(links_script)\n        except Exception as e:\n            return []\n    \n    async def _extract_images(self, page, max_images: int) -> List[Dict]:\n        \"\"\"Extract images\"\"\"\n        images_script = f\"\"\"\n        (function() {{\n            const images = [];\n            const imgTags = document.querySelectorAll('img');\n            const maxImages = Math.min(imgTags.length, {max_images});\n            \n            for (let i = 0; i < maxImages; i++) {{\n                const img = imgTags[i];\n                const src = img.getAttribute('src');\n                \n                if (src) {{\n                    try {{\n                        const absoluteUrl = new URL(src, window.location.href).href;\n                        images.push({{\n                            src: src,\n                            absolute_url: absoluteUrl,\n                            alt: img.getAttribute('alt') || null,\n                            width: img.width || null,\n                            height: img.height || null\n                        }});\n                    }} catch (e) {{\n                        // Skip invalid URLs\n                    }}\n                }}\n            }}\n            \n            return images;\n        }})()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(images_script)\n        except Exception as e:\n            return []\n    \n    async def _extract_text_content(self, page) -> Dict:\n        \"\"\"Extract text content\"\"\"\n        text_script = \"\"\"\n        (function() {\n            const body = document.body.cloneNode(true);\n            \n            // Remove script and style elements\n            const toRemove = body.querySelectorAll('script, style, noscript');\n            for (let i = 0; i < toRemove.length; i++) {\n                toRemove[i].remove();\n            }\n            \n            const fullText = body.textContent || body.innerText || '';\n            const words = fullText.split(/\\\\s+/).filter(function(word) { \n                return word.length > 0; \n            });\n            \n            // Get text from main content areas\n            let mainText = '';\n            const mainSelectors = ['main', 'article', '.content', '#content'];\n            for (let i = 0; i < mainSelectors.length; i++) {\n                const mainEl = document.querySelector(mainSelectors[i]);\n                if (mainEl) {\n                    mainText = mainEl.textContent || mainEl.innerText || '';\n                    break;\n                }\n            }\n            \n            return {\n                full_text: fullText.replace(/\\\\s+/g, ' ').trim(),\n                main_text: mainText.replace(/\\\\s+/g, ' ').trim(),\n                word_count: words.length,\n                char_count: fullText.length\n            };\n        })()\n        \"\"\"\n        \n        try:\n            return await page.evaluate(text_script)\n        except Exception as e:\n            return {'error': str(e)}\n    \n    def _generate_statistics(self, result: Dict) -> Dict:\n        \"\"\"Generate statistics about scraped data\"\"\"\n        stats = {\n            'extraction_success': result['status'] == 'success',\n            'error_count': len(result.get('errors', [])),\n            'table_count': len(result.get('data', {}).get('tables', [])),\n            'financial_table_count': len(result.get('data', {}).get('financial_data', [])),\n            'form_count': len(result.get('data', {}).get('forms', [])),\n            'link_count': len(result.get('data', {}).get('links', [])),\n            'image_count': len(result.get('data', {}).get('images', [])),\n            'has_structured_data': False\n        }\n        \n        # Check for financial data\n        financial_data = result.get('data', {}).get('financial_data', [])\n        if financial_data:\n            total_rows = sum(len(table.get('data', [])) for table in financial_data)\n            stats['financial_data_rows'] = total_rows\n            stats['has_structured_data'] = total_rows > 0\n        \n        return stats\n"
              },
              "extract_financial_tables": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Extract Financial Data",
                "dynamic": false,
                "info": "Extract and parse financial/crypto data tables",
                "list": false,
                "list_add_label": "Add More",
                "name": "extract_financial_tables",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "extract_forms": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Extract Forms",
                "dynamic": false,
                "info": "Extract form information",
                "list": false,
                "list_add_label": "Add More",
                "name": "extract_forms",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "extract_images": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Extract Images",
                "dynamic": false,
                "info": "Extract image information",
                "list": false,
                "list_add_label": "Add More",
                "name": "extract_images",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "extract_links": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Extract Links",
                "dynamic": false,
                "info": "Extract all links from the webpage",
                "list": false,
                "list_add_label": "Add More",
                "name": "extract_links",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "extract_metadata": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Extract Metadata",
                "dynamic": false,
                "info": "Extract page metadata and meta tags",
                "list": false,
                "list_add_label": "Add More",
                "name": "extract_metadata",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "extract_tables": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Extract Tables",
                "dynamic": false,
                "info": "Extract all tables from the webpage",
                "list": false,
                "list_add_label": "Add More",
                "name": "extract_tables",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "extract_text": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Extract Text",
                "dynamic": false,
                "info": "Extract text content from the webpage",
                "list": false,
                "list_add_label": "Add More",
                "name": "extract_text",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "headless": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Headless Mode",
                "dynamic": false,
                "info": "Run browser in headless mode (recommended for production)",
                "list": false,
                "list_add_label": "Add More",
                "name": "headless",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "max_images": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Images",
                "dynamic": false,
                "info": "Maximum number of images to extract",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_images",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 50
              },
              "max_links": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Links",
                "dynamic": false,
                "info": "Maximum number of links to extract",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_links",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 200
              },
              "max_tables": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Tables",
                "dynamic": false,
                "info": "Maximum number of tables to extract",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tables",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 20
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "Page load timeout in seconds",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "url": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URL",
                "dynamic": false,
                "info": "The URL to scrape",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "url",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "wait_time": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Wait Time",
                "dynamic": false,
                "info": "Wait time for dynamic content to load (seconds)",
                "list": false,
                "list_add_label": "Add More",
                "name": "wait_time",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 8
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "RobustWebScraperComponent"
        },
        "dragging": false,
        "id": "RobustWebScraperComponent-M1M0q",
        "measured": {
          "height": 972,
          "width": 320
        },
        "position": {
          "x": 422,
          "y": 27.5
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-GwNsP",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "https://docs.langflow.org/components-io#chat-input",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.5.0.post2",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatInput"
        },
        "id": "ChatInput-GwNsP",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 47.86160108548169,
          "y": 105.31275440976933
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-7Eeu3",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.5.0.post2",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([safe_convert(item, clean_data=self.clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "id": "ChatOutput-7Eeu3",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 1026.4559023066486,
          "y": 471.95590230664857
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParseData-8WTbu",
          "node": {
            "base_classes": [
              "Data",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert Data objects into Messages using any {field_name} from input data.",
            "display_name": "Data to Message",
            "documentation": "",
            "edited": false,
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "frozen": false,
            "icon": "message-square",
            "legacy": true,
            "lf_version": "1.5.0.post2",
            "metadata": {
              "legacy_name": "Parse Data"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "group_outputs": false,
                "method": "parse_data",
                "name": "text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data List",
                "group_outputs": false,
                "method": "parse_data_as_list",
                "name": "data_list",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import data_to_text, data_to_text_list\nfrom langflow.io import DataInput, MultilineInput, Output, StrInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Data to Message\"\n    description = \"Convert Data objects into Messages using any {field_name} from input data.\"\n    icon = \"message-square\"\n    name = \"ParseData\"\n    legacy = True\n    metadata = {\n        \"legacy_name\": \"Parse Data\",\n    }\n\n    inputs = [\n        DataInput(\n            name=\"data\",\n            display_name=\"Data\",\n            info=\"The data to convert to text.\",\n            is_list=True,\n            required=True,\n        ),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. \"\n            \"It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n            required=True,\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"text\",\n            info=\"Data as a single Message, with each input Data separated by Separator\",\n            method=\"parse_data\",\n        ),\n        Output(\n            display_name=\"Data List\",\n            name=\"data_list\",\n            info=\"Data as a list of new Data, each having `text` formatted by Template\",\n            method=\"parse_data_as_list\",\n        ),\n    ]\n\n    def _clean_args(self) -> tuple[list[Data], str, str]:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n        sep = self.sep\n        return data, template, sep\n\n    def parse_data(self) -> Message:\n        data, template, sep = self._clean_args()\n        result_string = data_to_text(template, data, sep)\n        self.status = result_string\n        return Message(text=result_string)\n\n    def parse_data_as_list(self) -> list[Data]:\n        data, template, _ = self._clean_args()\n        text_list, data_list = data_to_text_list(template, data)\n        for item, text in zip(data_list, text_list, strict=True):\n            item.set_text(text)\n        self.status = data_list\n        return data_list\n"
              },
              "data": {
                "_input_type": "DataInput",
                "advanced": false,
                "display_name": "Data",
                "dynamic": false,
                "info": "The data to convert to text.",
                "input_types": [
                  "Data"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sep": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{value}"
              }
            },
            "tool_mode": false
          },
          "selected_output": "text",
          "showNode": true,
          "type": "ParseData"
        },
        "dragging": false,
        "id": "ParseData-8WTbu",
        "measured": {
          "height": 264,
          "width": 320
        },
        "position": {
          "x": 823.9050203527814,
          "y": 603.736092265943
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 135.9197530864198,
      "y": 15.148662551440339,
      "zoom": 0.7582304526748971
    }
  },
  "description": "Tool for scraping website from URL, return scraped content in JSON format",
  "endpoint_name": null,
  "id": "8bc38540-b991-4c21-9b4c-104b5284425f",
  "is_component": false,
  "last_tested_version": "1.5.0.post2",
  "name": "subflow - scraper tool",
  "tags": []
}